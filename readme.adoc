= EDA Merging Service
:toc: left
:source-highlighter: pygments
:icons: font
// Github specifics
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

== Purpose

The EDA Merging Service plays the role in the greater EDA service system of merging single-entity
tabular data streams received from the Subsetting and Compute services into a single tabular stream,
which still represents a single entity, but which has gathered into it data from potentially many
other entities.  It also is responsible for the creation of Derived Variable data, which is generated
using these merged streams.

== Ways Data Can Be Merged

=== Inherited Variables

The most basic way data can be merged is through inherited variables.  The entity tree is organized
in a way such that, as you descend from the root entity, all children have a one-to-one or
many-to-one relationship with their parent.  This remains true with the application of subset
filters, as long as the same filters are applied to both entities during Subsetting Service requests.

Because of this, a record of a child entity has a unique parent ID, and a row for that ID is
guaranteed to be present in a parent entity stream of the same subset as the child.  Thus, one
can apply a parent's data to a child in a single pass of both streams by adding selected parent
variables to the tabular row of the child's stream.  This is what the merging service does and is
known as "inheriting" an ancestor entity's data.

=== Computed Variables

The EDA Compute Service asynchonously produces tabular data streams representing data for a single
entity.  These streams contain newly computed variables, which can be merged into a tabular data
stream by the Merging Service.  Typically the computed variables' entity matches the target entity
of the Merging service request; however, computed variables can be applied to any descendant
entity of the computed variable entity through inheritance (see above).

=== Derived Variables

Derived Variables are variables that are created in the Merging Service by plugins.  Additional
plugins can be written against a flexible Java API.  The input to these plugins is a specification
object whose schema is defined by the plugin.  Using the specification object, a plugin declares a
set of tabular streams it requires to generated the derived data.  These streams of data are fetched
from the Subsetting Service and, row-by-row, the plugin is applied to calculate new values.  Some
variable metadata is also produced by the plugin (any that can be produced without actually visiting
the data) but other variable metadata (e.g. num unique values) must be generated elsewhere.

There are two types of Derived Variables:

==== Transforms

Transforms are Derived Variables that take one or more variables on a single entity (or inherited
from an ancestor) and use their values to produce a new variable on the same entity.  An example of
this might be numeric addition, where the value of a new variable A is produced by adding the values
of B and C (B + C), where B and C are existing variables on the same entity or an ancestor.

==== Reductions

Reductions are Derived Variables that take one or more variables from multiple rows of a descendant
entity and functionally reduce them to a single value (i.e. iterate over them, applying a reduction
function to a row and some intermediate values).  An example of this might be to take a numeric
average or mean: if entity X is a parent of entity Y, and A is a varible of entity Y, then a plugin
could produce a new variable B on X whose value is the mean of A over Y's child rows of a single
row of X.

== Design

=== The Request

A merged tabular request consists of the following elements:

. Study ID: each request is based on a single study
. Entity ID: the entity of the response; the response will return one row for each record of this entity in the primary subset
. Output Variables: a list of variable spec objects (entity ID + variable ID); each of these will be a column in the tabular response
. Subset Filters (optional): list of objects, each of which describes a filter; together they define the primary request subset
. Compute Spec (optional): a compute plugin name and configuration which should be used to pull in computed variables
. Derived Variable Specs (optional): list of objects, each of which describes how to create a new derived variable

=== Preprocessing

Before generating the response, the merging service gathers required resources.  These include:
.. Pulling out the elements of the request and saving them off
.. Subsetting and Compute Service Clients: Objects that make it easy to request data from these services
.. Study Metadata: Use the study ID in the request to ask Subsetting for the study's metadata
.. Derived Variable Factory: An object configured with the incoming derived variable specs which can produce dependency-ordered, configured plugin instances
.. Computed Variable Metadata: Use the passed compute spec to ensure the compute job is complete and request and save off computed variable metadata

=== Processing

To serve a merged tabular response, the merging service executes the following steps:



=== About Headers

The header line of the merging service's tabular response consists of an ID column for the target
entity and each of its ancestors (in that order, up the tree), data columns for each of the
requested output variables, and columns for any computed variables generated by the specified
compute job.

The format of the header is different for incoming vs outgoing streams.  Because the compute and
subsetting services serve tabular responses for a single entity, their headers consist of only the
variable ID (no entity IDs).  However, a merging tabular response could have columns for multiple
entities (via inheritance), so we encode them in the format "<entity_id>.<variable_id>".
